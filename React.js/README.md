# React

## Virtual DOM

리액트는 Virtual DOM을 사용하여 성능을 향상시킨다. Virtual DOM은 실제 DOM과 동일한 구조를 가지지만, 메모리 상에만 존재하는 가벼운 복제본이다. 리액트는 이 가상 DOM을 사용하여 실제 DOM에 변경 사항이 필요한 경우에만 업데이트하므로 불필요한 렌더링을 방지하고 성능을 최적화할 수 있다.

## JSX

리액트에서는 JSX를 사용하여 컴포넌트를 정의한다. JSX는 자바스크립트의 확장 문법으로, HTML과 유사한 구문으로 작성된다. JSX는 리액트 컴포넌트를 작성할 때 매우 편리하며, 컴파일러를 사용하여 일반 자바스크립트 코드로 변환된다.

## 컴포넌트

리액트는 컴포넌트 기반 아키텍처를 사용한다. 컴포넌트는 UI의 작은 조각이며, 각각 독립적으로 작동할 수 있다. 이러한 컴포넌트는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달하고, 하위 컴포넌트에서는 상위 컴포넌트로 이벤트를 전달한다.

## 상태 관리

리액트에서는 상태(state)를 사용하여 컴포넌트 내부의 데이터를 관리한다. 상태는 컴포넌트가 렌더링될 때마다 변경될 수 있다. 상태를 업데이트하면 리액트는 해당 컴포넌트를 다시 렌더링하므로 UI가 업데이트된다.

## 라이프사이클 메서드

리액트 컴포넌트는 라이프사이클 메서드를 가지며, 컴포넌트가 생성, 업데이트 및 제거될 때 실행된다. 라이프사이클 메서드는 컴포넌트의 상태와 프로퍼티에 따라 실행되는 메서드가 다르다.

## 이벤트(Event)

React에서 이벤트(Event)는 HTML에서와 마찬가지로 사용자와의 상호작용을 처리하는데 사용된다.

- 이벤트 핸들러(Event Handler) 함수를 작성하여 이벤트를 처리한다. 핸들러 함수는 이벤트가 발생했을 때 실행된다.
- JSX에서 이벤트를 등록할 때는 camelCase 형태로 작성한다. 예를 들어 onClick, onMouseOver, onKeyDown와 같은 형태로 작성한다.
- 이벤트 객체(Event Object)를 사용하여 이벤트 정보에 접근할 수 있다. 예를 들어 클릭 이벤트에서는 이벤트 객체를 통해 마우스 좌표를 가져올 수 있다.

React에서는 이벤트의 기본 동작을 막기 위해 preventDefault() 메서드를 사용할 수 있다.

## 라우팅(Routing)

React에서 라우팅(Routing)은 사용자가 다른 페이지로 이동하는 방법을 처리한다. React Router를 사용하여 클라이언트 측 라우팅을 구현할 수 있다. 

### React Router

- Route: URL 경로와 연결된 컴포넌트를 렌더링한다.
- Link: 다른 페이지로 이동하는 링크를 제공한다.
- Switch: 여러 Route 중에서 매칭되는 첫 번째 Route만 렌더링한다.
- Redirect: URL을 다른 페이지로 리디렉션한다.

React Router는 SPA(Single Page Application)에서 사용자 경험을 향상시키는 데 매우 유용하다.

## 테스트(Test)

React 애플리케이션에서 테스트(Test)는 코드의 품질을 보장하고 버그를 방지하는 데 매우 중요하다. React에서는 Jest와 같은 테스트 프레임워크를 사용하여 다양한 종류의 테스트를 수행할 수 있다.

- 유닛 테스트(Unit Test): 단일 컴포넌트 또는 함수와 같은 작은 부분을 테스트한다.
- 통합 테스트(Integration Test): 여러 컴포넌트 간의 상호작용을 테스트한다.
- 스냅샷 테스트(Snapshot Test): 이전 렌더링 결과와 비교하여 UI 컴포넌트의 변경사항을 검사한다.

React에서는 테스트 코드 작성을 쉽게 할 수 있도록 Jest와 같은 도구가 제공된다.

## 서버사이드 렌더링(Server-side rendering, SSR)

React 컴포넌트를 서버에서 HTML로 변환하여 클라이언트에게 보내주는 기술이다. 클라이언트 측 렌더링(Client-side rendering, CSR)과는 달리, SSR은 서버에서 렌더링을 처리하기 때문에 초기 로딩 시간을 줄이고 SEO(Search Engine Optimization)에도 유리하다.

### SSR을 구현하는 방법

1. 서버사이드 렌더링을 지원하는 프레임워크를 사용한다.
- Next.js: React 프레임워크로, SSR을 지원하며, CSR도 가능하다.
- Gatsby: 정적 사이트 생성기로, React와 GraphQL을 사용하여 SSR을 지원한다.
2. Express와 같은 Node.js 서버를 사용하여 SSR을 직접 구현한다.
- React에서 제공하는 ReactDOMServer.renderToString() 메서드를 사용하여 컴포넌트를 HTML 문자열로 변환한다.
- Node.js 서버에서 렌더링된 HTML을 클라이언트에게 보내준다.
- 클라이언트에서는 React 컴포넌트를 마운트하는 대신, 서버에서 받은 HTML을 렌더링한다.

서버사이드 렌더링을 구현하는 것은 CSR에 비해 복잡하지만, 초기 로딩 속도와 SEO를 개선하는 데 매우 유용하다.



## Redux

### 개요

Redux는 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너이다. 애플리케이션의 상태를 관리하고, 상태 변경에 따라 UI를 업데이트하는 것이 주요 목적이다. Redux는 컴포넌트 간 데이터 전달을 단순화하고, 복잡한 애플리케이션의 상태 관리를 용이하게 한다.

### 주요 요소

## Store

Store는 애플리케이션의 상태를 포함하고, 상태 변경에 따라 새로운 상태를 생성한다. Store는 Redux 애플리케이션에서 단 하나만 존재하며, 상태에 접근하거나 변경할 때 사용된다.

## Action

Action은 상태 변경을 일으키는 객체이다. Action 객체는 type 속성을 반드시 가지며, 상태 변경에 필요한 다른 데이터를 추가로 포함할 수 있다.

## Reducer

Reducer는 현재 상태와 Action 객체를 받아서 새로운 상태를 반환하는 순수 함수이다. Reducer는 Redux 애플리케이션에서 여러 개가 존재할 수 있으며, 상태를 변경하는 로직을 구현한다.

## Dispatch

Dispatch는 Action을 전달하여 상태 변경을 발생시키는 메서드이다. Dispatch는 Store에서 호출되며, Action을 Reducer에 전달한다.

## 동작 방식

Redux는 상태를 변경하는 Action 객체를 만들어서 Dispatch 메서드를 호출한다. Dispatch 메서드는 Reducer에 현재 상태와 Action 객체를 전달하여 새로운 상태를 생성한다. 생성된 새로운 상태는 Store에 저장되고, 상태 변경에 따라 UI가 업데이트된다.

Redux는 단방향 데이터 흐름을 따르기 때문에, 상태 변경을 추적하거나 예측하기가 쉽다. 또한, 상태 변경을 위한 로직을 Reducer에서 구현하므로, 애플리케이션의 상태를 예측 가능하게 관리할 수 있다.

## Redux의 장점

- 예측 가능한 상태 관리: 단방향 데이터 흐름을 따라 상태 변경을 추적하고 예측하기가 쉽다.
- 복잡한 애플리케이션 관리: 컴포넌트 간 데이터 전달을 단순화하고, 상태 변경에 따른 로직을 중앙에서 관리할 수 있다.
