# 그래프 탐색 알고리즘

그래프는 정점과 간선으로 구성된 한정된 자료구조를 의미한다.

각각의 지점을 정점이라고 하고, 정점과 정점의 연결을 간선이라고 한다.

각 정점이 서로 연결되어 있는지, 주어진 시간 내에 탐색을 통해 확인하는 알고리즘이다.

## 대표적 문제유형

1. 경로탐색 유형(최단거리, 시간)
2. 네트위크 유형(연결)
3. 조합유형(모든 조합 만들기)
4. 암시적 그래프 표현(미로 탈출)

# DFS

## 깊이우선 탐색

하나를 몰아서 보는 것

재귀함수가 가장 일반적

재귀를 타고, 타고, 타서 탈출 조건에 먼저 도달하고 그 다음에 파라미터를 하나씩 바꿔 가면서 정답을 찾는 방식

DFS는 수행 시간 관점에서 초과가 발생할 수 있다.

작동원리:
시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고 더 갈 곳이 없다면 이전의 경로로 되돌아간다.

### 단점

- 재귀함수를 이용하기 때문에 함수 호출 비용이 추가로 들어간다.
- 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어렵다.
- 최단 경로를 알 수 없다.

## 정리

- 가장 직관적이고 구현하기 쉬운 탐색방법
- 현재 정점과 연결된 정점들으 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위를 반복한다.
- 같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시해 준다.
- 재귀 함수를 통해 구현한다.

# BFS

## 넓이우선 탐색

여러개를 하나씩 보는 것

Queue/LinkedList 를 사용하는 것이 보편적

Queue에 경우

1. 시작점을 큐에 넣는다. 이후 큐가 빌 때까지 루프를 돌린다.
2. 큐의 제일 앞에 있는 정점을 뽑는다.
   - 뽑은 지점과 연결된 정점을 큐에 추가한다.
   - 뽑은 지점이 목표 정점이라면 루프를 종료한다.
3. 만약 목표 지점을 찾지 못하더라도, 더 갈 수 있는 지점이 없으면 루프가 종료된다.

순서가 보장되어야 하기 때문에 Queue나 LinkedList를 사용하는 것

BFS는 시간복잡도가 낮다.

작동원리: 시작점 기준으로 거리가 1인 모든 지점을 탐색하고 이후 2인 지점을 탐색... 하는 식으로 모든 지점을 탐색한다. 목표 지점을 찾으면 탐색을 종료하고 찾지 못했다면 연결된 모든 지점을 탐색한다.

### 장점

- 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적이다.
- 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있다.
  - 간선의 비용이 각각 다를 경우, 다익스트라 알고리즘 등의 최단거리 알고리즘을 활용해야 한다.

### 단점

- DFS에 비해 코드 구현이 어렵다.
- 모든 지점을 탐색할 경우를 대비해, 큐의 메모리가 미리 준비되어 있어야 한다. (메모리 자체를 효율적으로 쓰지만 기본적으로 많이 듬)

## 정리

- 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘
- 큐를 이용하여 구현한다.
- 출발점을 먼저 큐에 넣고 다음 로직을 반복한다.
  - 큐에 저장된 정점을 하나 Dequeue한다
  - Dequeue된 정점과 연결된 모든 정점을 큐에 넣는다.
  - 큐가 비어있다면 반복을 종료한다.
